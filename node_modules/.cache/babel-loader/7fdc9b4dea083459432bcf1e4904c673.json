{"ast":null,"code":"/*\n * Trianglify.js\n * by @qrohlf\n *\n * Licensed under the GPLv3\n */\nvar Delaunator = require('delaunator');\n\nvar seedrandom = require('seedrandom');\n\nvar chroma = require('chroma-js'); //PROBLEM: chroma.js is nearly 32k in size\n\n\nvar colorbrewer = require('./colorbrewer'); //We could use the chroma.js colorbrewer, but it's got some ugly stuff so we use our own subset.\n\n\nvar _generate_points = require('./points');\n\nvar Pattern = require('./pattern');\n\nvar defaults = {\n  width: 600,\n  // Width of pattern\n  height: 400,\n  // Height of pattern\n  cell_size: 75,\n  // Size of the cells used to generate a randomized grid\n  variance: 0.75,\n  // how much to randomize the grid\n  seed: null,\n  // Seed for the RNG\n  x_colors: 'random',\n  // X color stops\n  y_colors: 'match_x',\n  // Y color stops\n  palette: colorbrewer,\n  // Palette to use for 'random' color option\n  color_space: 'lab',\n  // Color space used for gradient construction & interpolation\n  color_function: null,\n  // Color function f(x, y) that returns a color specification that is consumable by chroma-js\n  stroke_width: 1.51,\n  // Width of stroke. Defaults to 1.51 to fix an issue with canvas antialiasing.\n  points: undefined // An Array of [x,y] coordinates to trianglulate. Defaults to undefined, and points are generated.\n\n};\n/*********************************************************\n*\n* Main function that is exported to the global namespace\n*\n**********************************************************/\n\nfunction Trianglify(opts) {\n  var rand; // apply defaults\n\n  opts = _merge_opts(defaults, opts); // setup seedable RNG\n\n  rand = seedrandom(opts.seed); // randomize colors if requested\n\n  if (opts.x_colors === 'random') opts.x_colors = _random_from_palette();\n  if (opts.y_colors === 'random') opts.y_colors = _random_from_palette();\n  if (opts.y_colors === 'match_x') opts.y_colors = opts.x_colors; // some sanity-checking\n\n  if (!(opts.width > 0 && opts.height > 0)) {\n    throw new Error(\"Width and height must be numbers greater than 0\");\n  }\n\n  if (opts.cell_size < 2) {\n    throw new Error(\"Cell size must be greater than 2.\");\n  }\n\n  if (!opts.x_colors && !opts.y_colors) {\n    throw new Error(\"X and Y colors can not be both undefined.\");\n  } // Setup the color gradient function\n\n\n  var gradient;\n\n  if (opts.color_function) {\n    gradient = function gradient(x, y) {\n      return chroma(opts.color_function(x, y));\n    };\n  } else {\n    // Both colors are specified: Interpolate between both.\n    if (opts.x_colors && opts.y_colors) {\n      var x_color = chroma.scale(opts.x_colors).mode(opts.color_space);\n      var y_color = chroma.scale(opts.y_colors).mode(opts.color_space);\n\n      gradient = function gradient(x, y) {\n        return chroma.interpolate(x_color(x), y_color(y), 0.5, opts.color_space);\n      };\n    } else {\n      // One color missing: Use only the specified one.\n      var scale = chroma.scale(opts.x_colors || opts.y_colors).mode(opts.color_space);\n      gradient = opts.x_colors ? function (x, y) {\n        return scale(x);\n      } : function (x, y) {\n        return scale(y);\n      };\n    }\n  } // Figure out key dimensions\n  // it's a pain to prefix width and height with opts all the time, so let's\n  // give them proper variables to refer to\n\n\n  var width = opts.width;\n  var height = opts.height; // How many cells we're going to have on each axis (pad by 2 cells on each edge)\n\n  var cells_x = Math.floor((width + 4 * opts.cell_size) / opts.cell_size);\n  var cells_y = Math.floor((height + 4 * opts.cell_size) / opts.cell_size); // figure out the bleed widths to center the grid\n\n  var bleed_x = (cells_x * opts.cell_size - width) / 2;\n  var bleed_y = (cells_y * opts.cell_size - height) / 2; // how much can out points wiggle (+/-) given the cell padding?\n\n  var variance = opts.cell_size * opts.variance / 2; // Set up normalizers\n\n  var norm_x = function norm_x(x) {\n    return _clamp(_map(x, [0, width], [0, 1]), [0, 1]);\n  };\n\n  var norm_y = function norm_y(y) {\n    return _clamp(_map(y, [0, height], [0, 1]), [0, 1]);\n  };\n\n  function _clamp(num, interval) {\n    return Math.min(Math.max(num, interval[0]), interval[1]);\n  } // generate a point mesh\n\n\n  var points = opts.points || _generate_points(width, height, bleed_x, bleed_y, opts.cell_size, variance, rand); // delaunay.triangulate gives us indices into the original coordinate array\n\n\n  var geom_indices = new Delaunator(points).triangles; // iterate over the indices in groups of three to flatten them into polygons, with color lookup\n\n  var triangles = [];\n\n  var lookup_point = function lookup_point(i) {\n    return points[i];\n  };\n\n  for (var i = 0; i < geom_indices.length; i += 3) {\n    var vertices = [geom_indices[i], geom_indices[i + 1], geom_indices[i + 2]].map(lookup_point);\n\n    var centroid = _centroid(vertices);\n\n    var color = gradient(norm_x(centroid.x), norm_y(centroid.y)).css();\n    triangles.push([color, vertices]);\n  }\n\n  return Pattern(triangles, opts);\n  /*********************************************************\n  *\n  * Private functions\n  *\n  **********************************************************/\n\n  function _map(num, in_range, out_range) {\n    return (num - in_range[0]) * (out_range[1] - out_range[0]) / (in_range[1] - in_range[0]) + out_range[0];\n  } //triangles only!\n\n\n  function _centroid(d) {\n    return {\n      x: (d[0][0] + d[1][0] + d[2][0]) / 3,\n      y: (d[0][1] + d[1][1] + d[2][1]) / 3\n    };\n  } // select a random palette from colorbrewer\n\n\n  function _random_from_palette() {\n    if (opts.palette instanceof Array) {\n      return opts.palette[Math.floor(rand() * opts.palette.length)];\n    }\n\n    var keys = Object.keys(opts.palette);\n    return opts.palette[keys[Math.floor(rand() * keys.length)]];\n  } // shallow extend (sort of) for option defaults\n\n\n  function _merge_opts(defaults, options) {\n    var out = {}; // shallow-copy defaults so we don't mutate the input objects (bad)\n\n    for (var key in defaults) {\n      out[key] = defaults[key];\n    }\n\n    for (key in options) {\n      if (defaults.hasOwnProperty(key)) {\n        out[key] = options[key]; // override defaults with options\n      } else {\n        throw new Error(key + \" is not a configuration option for Trianglify. Check your spelling?\");\n      }\n    }\n\n    return out;\n  }\n} //end of Trianglify function closure\n// exports\n\n\nTrianglify.colorbrewer = colorbrewer;\nTrianglify.defaults = defaults;\nmodule.exports = Trianglify;","map":null,"metadata":{},"sourceType":"script"}